{"task_id": "HumanEval/0", "solution": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The minimum distance between two numbers to be considered close.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Iterate over the sorted list\n    for i in range(len(numbers) - 1):\n        # Check if the difference between the current number and the next number is less than the threshold\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If no close elements are found, return False\n    return False\n\n# Test cases"}
{"task_id": "HumanEval/1", "solution": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function separates groups of balanced parentheses in a given string into a list of strings.\n\n    Args:\n    paren_string (str): A string containing multiple groups of nested parentheses.\n\n    Returns:\n    List[str]: A list of strings, each representing a group of balanced parentheses.\n    \"\"\"\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n\n    # Initialize an empty list to store the groups\n    groups = []\n\n    # Initialize an empty string to build the current group\n    current_group = \"\"\n\n    # Initialize a counter to keep track of the balance of parentheses\n    balance = 0\n\n    # Iterate over each character in the string\n    for char in paren_string:\n        # If the character is an open parenthesis, increase the balance\n        if char == \"(\":\n            balance += 1\n            current_group += char\n        # If the character is a close parenthesis, decrease the balance\n        elif char == \")\":\n            balance -= 1\n            current_group += char\n            # If the balance is zero, it means we've found a complete group\n            if balance == 0:\n                groups.append(current_group)\n                current_group = \"\"\n        # If the character is not a parenthesis, skip it\n\n    return groups\n\n# Test the function"}
{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n\n    Args:\n        number (float): A positive floating point number.\n\n    Returns:\n        float: The decimal part of the number.\n\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number - int(number)\n\n# Test the function"}
{"task_id": "HumanEval/3", "solution": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    This function checks if at any point the balance of a bank account falls below zero.\n    \n    Args:\n    operations (List[int]): A list of deposit and withdrawal operations on a bank account.\n    \n    Returns:\n    bool: True if the balance falls below zero at any point, False otherwise.\n    \"\"\"\n    balance = 0  # Initialize the balance to zero\n    for operation in operations:  # Iterate over each operation in the list\n        balance += operation  # Add the operation to the balance\n        if balance < 0:  # Check if the balance falls below zero\n            return True  # If it does, return True\n    return False  # If the loop completes without the balance falling below zero, return False\n\n# Test cases"}
{"task_id": "HumanEval/4", "solution": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    # Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute difference between each element and the mean\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad\n\n# Test the function"}
{"task_id": "HumanEval/5", "solution": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Insert a number 'delimeter' between every two consecutive elements of input list `numbers'.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n        delimeter (int): The number to be inserted between elements.\n\n    Returns:\n        List[int]: The modified list with the delimeter inserted.\n    \"\"\"\n    if not numbers:  # If the input list is empty, return it as is\n        return numbers\n    \n    result = [numbers[0]]  # Start with the first element of the list\n    for num in numbers[1:]:  # Iterate over the rest of the list\n        result.append(delimeter)  # Insert the delimeter\n        result.append(num)  # Append the current number\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/6", "solution": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    This function takes a string of nested parentheses as input, separated by spaces.\n    It returns a list of the maximum depth of nesting for each group of parentheses.\n\n    Args:\n        paren_string (str): A string of nested parentheses.\n\n    Returns:\n        List[int]: A list of maximum depth of nesting for each group of parentheses.\n    \"\"\"\n    def max_depth(s: str) -> int:\n        \"\"\"Helper function to calculate the maximum depth of a string of parentheses.\"\"\"\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    # Split the input string into groups of parentheses\n    groups = paren_string.split()\n    # Calculate the maximum depth of each group and return the result\n    return [max_depth(group) for group in groups]\n\n# Test the function"}
{"task_id": "HumanEval/7", "solution": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that contain given substring\n\n    Args:\n        strings (List[str]): A list of strings to be filtered\n        substring (str): The substring to search for in the input list\n\n    Returns:\n        List[str]: A list of strings that contain the given substring\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n# Test cases"}
{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        Tuple[int, int]: A tuple containing the sum and product of the input list.\n    \"\"\"\n    # Initialize sum and product with default values\n    total_sum = 0\n    total_product = 1\n\n    # Iterate over the list of numbers\n    for num in numbers:\n        # Add the current number to the sum\n        total_sum += num\n        # Multiply the current number with the product\n        total_product *= num\n\n    # Return the sum and product as a tuple\n    return total_sum, total_product\n\n# Test cases"}
{"task_id": "HumanEval/9", "solution": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n\n    Example:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result\n\n# Test the function"}
{"task_id": "HumanEval/10", "solution": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if not string:\n        return ''\n\n    # Find the longest palindromic suffix\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[i:]):\n            # Reverse the prefix and append to the palindromic suffix\n            return string[:i] + string[i:][::-1]\n\n    # If no palindromic suffix is found, return the original string\n    return string\n\n\n# Test cases"}
{"task_id": "HumanEval/11", "solution": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    This function performs binary XOR operation on two input strings consisting of 1s and 0s.\n\n    Args:\n        a (str): The first binary string.\n        b (str): The second binary string.\n\n    Returns:\n        str: The result of the binary XOR operation as a string.\n\n    Example:\n        >>> string_xor('010', '110')\n        '100'\n    \"\"\"\n    # Check if both inputs are strings\n    if not isinstance(a, str) or not isinstance(b, str):\n        raise TypeError(\"Both inputs must be strings\")\n\n    # Check if both strings consist only of 1s and 0s\n    if not set(a).issubset({'0', '1'}) or not set(b).issubset({'0', '1'}):\n        raise ValueError(\"Both inputs must consist only of 1s and 0s\")\n\n    # Perform XOR operation on corresponding bits\n    result = ''.join('1' if (a[i] == '1' and b[i] == '0') or (a[i] == '0' and b[i] == '1') else '0' for i in range(max(len(a), len(b))))\n\n    return result"}
{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Out of list of strings, return the longest one. \n    Return the first one in case of multiple strings of the same length. \n    Return None in case the input list is empty.\n\n    Args:\n        strings (List[str]): A list of strings.\n\n    Returns:\n        Optional[str]: The longest string in the list, or None if the list is empty.\n    \"\"\"\n    if not strings:\n        return None\n    return max(strings, key=len)\n\n# Test cases"}
{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return a greatest common divisor of two integers a and b\n\n    Args:\n        a (int): The first integer\n        b (int): The second integer\n\n    Returns:\n        int: The greatest common divisor of a and b\n\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)\n\n# Test the function"}
{"task_id": "HumanEval/14", "solution": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"\n    Return list of all prefixes from shortest to longest of the input string\n\n    Args:\n        string (str): The input string\n\n    Returns:\n        List[str]: A list of all prefixes of the input string, from shortest to longest\n    \"\"\"\n    prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes\n\n# Test the function"}
{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int) -> str:\n    \"\"\"\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n\n    Args:\n        n (int): The upper limit of the sequence.\n\n    Returns:\n        str: A string containing space-delimited numbers from 0 to n.\n    \"\"\"\n    return ' '.join(map(str, range(n + 1)))\n\n# Test cases"}
{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n        string (str): The input string\n\n    Returns:\n        int: The number of distinct characters in the string\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(lower_case_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)\n\n# Test cases"}
{"task_id": "HumanEval/17", "solution": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parse a string of musical notes and return a list of integers representing the number of beats each note lasts.\n\n    Args:\n    music_string (str): A string of musical notes in the format 'o', 'o|', or '.|'.\n\n    Returns:\n    List[int]: A list of integers representing the number of beats each note lasts.\n    \"\"\"\n    # Define a dictionary to map note types to their corresponding beat lengths\n    note_lengths = {'o': 4, 'o|': 2, '.|': 1}\n\n    # Split the input string into individual notes\n    notes = music_string.split()\n\n    # Use a list comprehension to create a list of note lengths\n    note_lengths_list = [note_lengths[note] for note in notes]\n\n    return note_lengths_list\n\n# Test the function"}
{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Find how many times a given substring can be found in the original string.\n    Count overlapping cases.\n\n    Args:\n        string (str): The original string to search in.\n        substring (str): The substring to search for.\n\n    Returns:\n        int: The number of times the substring can be found in the string.\n    \"\"\"\n    count = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            count += 1\n    return count\n\n# Test cases"}
{"task_id": "HumanEval/19", "solution": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Sorts a space-delimited string of numbers from 'zero' to 'nine' in ascending order.\n\n    Args:\n        numbers (str): A space-delimited string of numbers from 'zero' to 'nine'.\n\n    Returns:\n        str: The input string with numbers sorted from smallest to largest.\n    \"\"\"\n    # Define a dictionary to map number names to their integer values\n    num_dict = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n\n    # Split the input string into a list of numbers\n    num_list: List[str] = numbers.split()\n\n    # Sort the list of numbers based on their integer values\n    sorted_num_list: List[str] = sorted(num_list, key=lambda x: num_dict[x])\n\n    # Join the sorted list back into a string\n    sorted_string: str = ' '.join(sorted_num_list)\n\n    return sorted_string\n\n# Test the function"}
{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n\n    Returns:\n        Tuple[float, float]: A tuple of two numbers that are the closest to each other.\n\n    Raises:\n        ValueError: If the input list has less than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two elements\")\n\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Initialize the minimum difference and the pair of closest numbers\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[0])\n\n    # Iterate over the sorted list to find the pair with the minimum difference\n    for i in range(1, len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair\n\n# Test cases"}
{"task_id": "HumanEval/21", "solution": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n\n    Args:\n        numbers (List[float]): A list of numbers\n\n    Returns:\n        List[float]: The rescaled list of numbers\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n\n    return [(n - min_val) / (max_val - min_val) for n in numbers]\n\n# Test the function"}
{"task_id": "HumanEval/22", "solution": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"\n    Filter given list of any python values only for integers.\n\n    Args:\n        values (List[Any]): A list of any python values.\n\n    Returns:\n        List[int]: A list of integers from the input list.\n\n    Examples:\n        >>> filter_integers(['a', 3.14, 5])\n        [5]\n        >>> filter_integers([1, 2, 3, 'abc', {}, []])\n        [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]\n\n# Test the function"}
{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n    \"\"\"\n    Return length of given string\n\n    Args:\n        string (str): The input string\n\n    Returns:\n        int: The length of the input string\n\n    Examples:\n        >>> strlen('')\n        0\n        >>> strlen('abc')\n        3\n    \"\"\"\n    return len(string)\n\n# Test cases"}
{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n        n (int): The input number\n\n    Returns:\n        int: The largest divisor of n smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Return 1 if n is a prime number\n\n# Test the function"}
{"task_id": "HumanEval/25", "solution": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n\n    Args:\n        n (int): The number to factorize\n\n    Returns:\n        List[int]: A list of prime factors\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n# Test cases"}
{"task_id": "HumanEval/26", "solution": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of integers with duplicates removed.\n    \"\"\"\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result\n\n# Test the function"}
{"task_id": "HumanEval/27", "solution": "def flip_case(string: str) -> str:\n    \"\"\"\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n\n    Args:\n        string (str): The input string to be flipped.\n\n    Returns:\n        str: The string with all lowercase characters converted to uppercase and vice versa.\n\n    Example:\n        >>> flip_case('Hello')\n        'hELLO'\n    \"\"\"\n    return ''.join(char.swapcase() for char in string)\n\n# Test the function"}
{"task_id": "HumanEval/28", "solution": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Concatenate list of strings into a single string\n\n    Args:\n        strings (List[str]): A list of strings to be concatenated\n\n    Returns:\n        str: A single string that is the result of concatenating all input strings\n\n    Examples:\n        >>> concatenate([])\n        ''\n        >>> concatenate(['a', 'b', 'c'])\n        'abc'\n    \"\"\"\n    return ''.join(strings)\n\n# Test the function"}
{"task_id": "HumanEval/29", "solution": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that start with a given prefix.\n\n    Args:\n        strings (List[str]): A list of strings to be filtered.\n        prefix (str): The prefix to filter by.\n\n    Returns:\n        List[str]: A list of strings that start with the given prefix.\n    \"\"\"\n    return [string for string in strings if string.startswith(prefix)]\n\n# Test cases"}
{"task_id": "HumanEval/30", "solution": "def get_positive(numbers: list) -> list:\n    \"\"\"\n    Return a list of positive numbers from the input list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A list of positive numbers.\n    \"\"\"\n    return [num for num in numbers if num > 0]\n\n# Test cases"}
{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\n    Args:\n        n (int): The number to check for primality.\n\n    Returns:\n        bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        # Numbers less than or equal to 1 are not prime\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        # Check for divisibility up to the square root of n\n        if n % i == 0:\n            # If n is divisible by any number, it's not prime\n            return False\n    # If no divisors are found, the number is prime\n    return True\n\n# Test cases"}
{"task_id": "HumanEval/32", "solution": "import math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    \"\"\"\n    # Check if the list has an even number of coefficients\n    if len(xs) % 2 != 0:\n        raise ValueError(\"List must have an even number of coefficients\")\n\n    # Find the largest non-zero coefficient\n    max_non_zero_coeff = max(coeff for coeff in xs if coeff != 0)\n\n    # Find the index of the largest non-zero coefficient\n    max_non_zero_index = xs.index(max_non_zero_coeff)\n\n    # Calculate the root\n    root = -xs[max_non_zero_index - 1] / xs[max_non_zero_index]\n\n    return root\n\n\n# Test cases"}
{"task_id": "HumanEval/33", "solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, \n    while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    Args:\n        l (list): The input list.\n\n    Returns:\n        list: The modified list.\n    \"\"\"\n    return [x if i % 3 != 0 else sorted([y for i, y in enumerate(l) if i % 3 == 0])[j // 3] \n            for i, x in enumerate(l) for j in range(3) if i % 3 == j]\n\n# Test cases"}
{"task_id": "HumanEval/34", "solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list\n\n    Args:\n        l (list): The input list\n\n    Returns:\n        list: A sorted list of unique elements\n\n    Example:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))\n\n# Test the function"}
{"task_id": "HumanEval/35", "solution": "def max_element(lst: list) -> int:\n    \"\"\"\n    Return the maximum element in the list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The maximum element in the list.\n\n    Examples:\n        >>> max_element([1, 2, 3])\n        3\n        >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n        123\n    \"\"\"\n    return max(lst)\n\n# Test the function"}
{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit for the range of numbers to check.\n\n    Returns:\n        int: The number of times the digit 7 appears in the specified range.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string to easily check for the digit 7\n            str_i = str(i)\n            # Count the occurrences of the digit 7\n            count += str_i.count('7')\n    return count\n\n# Test cases"}
{"task_id": "HumanEval/37", "solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\n    Args:\n        l (list): The input list.\n\n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Separate the list into two lists, one for odd indices and one for even indices\n    odd = [x for i, x in enumerate(l) if i % 2 != 0]\n    even = [x for i, x in enumerate(l) if i % 2 == 0]\n\n    # Sort the list of even indices\n    even.sort()\n\n    # Combine the two lists, replacing the even indices with the sorted even values\n    result = []\n    for i, x in enumerate(l):\n        if i % 2 == 0:\n            result.append(even[i // 2])\n        else:\n            result.append(x)\n\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/38", "solution": "def encode_cyclic(s: str):\n    \"\"\"\n    Returns encoded string by cycling groups of three characters.\n    \n    Args:\n    s (str): The input string to be encoded.\n    \n    Returns:\n    str: The encoded string.\n    \"\"\"\n    # Split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # Cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    \n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    Takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \n    Args:\n    s (str): The encoded string to be decoded.\n    \n    Returns:\n    str: The decoded string.\n    \"\"\"\n    # Initialize an empty string to store the decoded result\n    decoded_str = \"\"\n    \n    # Initialize a counter to keep track of the current position in the string\n    i = 0\n    \n    # Loop through the string in steps of 3\n    while i < len(s):\n        # If the current position is at the end of the string, add the remaining characters to the decoded string\n        if i + 2 >= len(s):\n            decoded_str += s[i:]\n            break\n        \n        # If the current position is at the start of a group of 3, add the group to the decoded string\n        if i % 3 == 0:\n            decoded_str += s[i:i+3]\n            i += 3\n        # If the current position is in the middle of a group of 3, cycle the characters and add the result to the decoded string\n        else:\n            decoded_str += s[i+1] + s[i] + s[i+2]\n            i += 3\n    \n    return decoded_str\n\n\n# Test the functions"}
{"task_id": "HumanEval/39", "solution": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Checks if a number is prime.\n    \n    Args:\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    Returns the n-th number that is a Fibonacci number and it's also prime.\n    \n    Args:\n    n (int): The position of the number in the Fibonacci sequence.\n    \n    Returns:\n    int: The n-th Fibonacci number that is also prime.\n    \"\"\"\n    a, b = 0, 1\n    count = 0\n    while True:\n        a, b = b, a + b\n        if is_prime(b):\n            count += 1\n            if count == n:\n                return b\n\n\n# Test cases"}
{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to find three elements that sum to zero\n    l.sort()\n    \n    # Iterate over the list\n    for i in range(len(l) - 2):\n        # Initialize two pointers, one at the next element and one at the end of the list\n        left = i + 1\n        right = len(l) - 1\n        \n        # Continue iterating over the list until the two pointers meet\n        while left < right:\n            # Calculate the current sum\n            current_sum = l[i] + l[left] + l[right]\n            \n            # If the current sum is zero, return True\n            if current_sum == 0:\n                return True\n            # If the current sum is less than zero, move the left pointer to the right\n            elif current_sum < 0:\n                left += 1\n            # If the current sum is greater than zero, move the right pointer to the left\n            else:\n                right -= 1\n                \n    # If no three elements sum to zero, return False\n    return False\n\n# Test cases"}
{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of n cars moving in opposite directions.\n\n    Args:\n    n (int): The number of cars in each set.\n\n    Returns:\n    int: The number of collisions.\n    \"\"\"\n    # The number of collisions is equal to the number of pairs of cars that can meet.\n    # Since the cars are moving in opposite directions, each pair of cars will meet once.\n    # The number of pairs of cars is equal to the number of ways to choose 2 cars from n cars.\n    # This can be calculated using the combination formula: n choose 2 = n * (n - 1) / 2\n    return n * (n - 1) // 2\n\n# Example usage:"}
{"task_id": "HumanEval/42", "solution": "def incr_list(l: list) -> list:\n    \"\"\"\n    Return list with elements incremented by 1.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A new list with elements incremented by 1.\n    \"\"\"\n    return [x + 1 for x in l]\n\n# Test cases"}
{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n\n# Test cases"}
{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int) -> str:\n    \"\"\"\n    Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    Base numbers are less than 10.\n\n    Args:\n        x (int): The number to be converted.\n        base (int): The target base.\n\n    Returns:\n        str: The string representation of x in the target base.\n    \"\"\"\n    if x == 0:\n        return '0'\n\n    digits = '0123456789'\n    result = ''\n\n    while x:\n        result = digits[x % base] + result\n        x //= base\n\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"\n    Given length of a side and height return area for a triangle.\n\n    Args:\n        a (float): The base length of the triangle.\n        h (float): The height of the triangle.\n\n    Returns:\n        float: The area of the triangle.\n\n    Examples:\n        >>> triangle_area(5, 3)\n        7.5\n    \"\"\"\n    return 0.5 * a * h\n\n# Test the function"}
{"task_id": "HumanEval/46", "solution": "def fib4(n: int) -> int:\n    \"\"\"\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\n    Args:\n        n (int): The position of the number in the sequence.\n\n    Returns:\n        int: The nth number in the Fib4 sequence.\n    \"\"\"\n    if n <= 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        fib4_sequence = [0, 0, 2, 0]\n        for i in range(4, n + 1):\n            fib4_sequence.append(fib4_sequence[i-1] + fib4_sequence[i-2] + fib4_sequence[i-3] + fib4_sequence[i-4])\n        return fib4_sequence[n]\n\n# Test cases"}
{"task_id": "HumanEval/47", "solution": "def median(l: list):\n    \"\"\"\n    Return median of elements in the list l.\n\n    Args:\n        l (list): A list of numbers.\n\n    Returns:\n        float: The median of the list.\n\n    Examples:\n        >>> median([3, 1, 2, 4, 5])\n        3\n        >>> median([-10, 4, 6, 1000, 10, 20])\n        15.0\n    \"\"\"\n    # Sort the list in ascending order\n    sorted_l = sorted(l)\n    \n    # Get the length of the list\n    n = len(sorted_l)\n    \n    # If the length of the list is odd, the median is the middle element\n    if n % 2 != 0:\n        return sorted_l[n // 2]\n    \n    # If the length of the list is even, the median is the average of the two middle elements\n    else:\n        mid1 = sorted_l[n // 2 - 1]\n        mid2 = sorted_l[n // 2]\n        return (mid1 + mid2) / 2\n\n# Test cases"}
{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n\n    Args:\n        text (str): The input string to check.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Remove any non-alphanumeric characters and convert to lowercase\n    cleaned_text = ''.join(char for char in text if char.isalnum()).lower()\n    \n    # Compare the cleaned text with its reverse\n    return cleaned_text == cleaned_text[::-1]\n\n# Test cases"}
{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)\n\n# Test cases"}
{"task_id": "HumanEval/50", "solution": "def encode_shift(s: str):\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    \n    This function assumes that the input string only contains lowercase English letters.\n    \n    Parameters:\n    s (str): The input string to be encoded.\n    \n    Returns:\n    str: The encoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\") + 5) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    Takes as input string encoded with encode_shift function. Returns decoded string.\n    \n    This function assumes that the input string only contains lowercase English letters.\n    \n    Parameters:\n    s (str): The input string to be decoded.\n    \n    Returns:\n    str: The decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\") - 5) % 26) + ord(\"a\")) for ch in s])\n\n\n# Test cases"}
{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    Parameters:\n    text (str): The input string.\n    \n    Returns:\n    str: The input string without vowels.\n    \"\"\"\n    # Define a string of vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels from the input string\n    # The if condition checks if a character is not in the vowels string\n    # The join function is used to concatenate the characters back into a string\n    return ''.join([char for char in text if char not in vowels])\n\n# Test cases"}
{"task_id": "HumanEval/52", "solution": "def below_threshold(lst: list, threshold: int) -> bool:\n    \"\"\"\n    Return True if all numbers in the list are below the threshold.\n\n    Args:\n        lst (list): A list of numbers.\n        threshold (int): The threshold value.\n\n    Returns:\n        bool: True if all numbers in the list are below the threshold, False otherwise.\n    \"\"\"\n    return all(num < threshold for num in lst)\n\n# Test cases"}
{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int) -> int:\n    \"\"\"\n    Add two numbers x and y\n\n    Args:\n        x (int): The first number to add\n        y (int): The second number to add\n\n    Returns:\n        int: The sum of x and y\n\n    Examples:\n        >>> add(2, 3)\n        5\n        >>> add(5, 7)\n        12\n    \"\"\"\n    return x + y\n\n# Test the function"}
{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n        s0 (str): The first word.\n        s1 (str): The second word.\n\n    Returns:\n        bool: True if the words have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets of characters, which automatically removes duplicates\n    # and makes it easy to compare the characters\n    return set(s0) == set(s1)\n\n\n# Test cases"}
{"task_id": "HumanEval/55", "solution": "def fib(n: int) -> int:\n    \"\"\"\n    Return n-th Fibonacci number.\n\n    Args:\n        n (int): The position of the Fibonacci number to return.\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Examples:\n        >>> fib(10)\n        55\n        >>> fib(1)\n        1\n        >>> fib(8)\n        21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n\n# Test the function"}
{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Checks if every opening bracket in the string has a corresponding closing bracket.\n\n    Args:\n    brackets (str): A string consisting of \"<\" and \">\".\n\n    Returns:\n    bool: True if every opening bracket has a corresponding closing bracket, False otherwise.\n    \"\"\"\n    stack = []  # Initialize an empty stack\n\n    for bracket in brackets:\n        if bracket == \"<\":  # If the current character is an opening bracket\n            stack.append(bracket)  # Push it onto the stack\n        elif bracket == \">\":  # If the current character is a closing bracket\n            if not stack:  # If the stack is empty\n                return False  # Return False because there's no corresponding opening bracket\n            stack.pop()  # Pop the opening bracket from the stack\n\n    return not stack  # Return True if the stack is empty (all brackets were matched), False otherwise\n\n# Test cases"}
{"task_id": "HumanEval/57", "solution": "def monotonic(lst: list) -> bool:\n    \"\"\"\n    Return True if list elements are monotonically increasing or decreasing.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        bool: True if the list is monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1)) or all(lst[i] >= lst[i+1] for i in range(len(lst)-1))\n\n# Test cases"}
{"task_id": "HumanEval/58", "solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n\n    Returns:\n        list: A sorted list of unique common elements.\n    \"\"\"\n    # Convert lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the intersection of the two sets (i.e., common elements)\n    common_elements = set1 & set2\n\n    # Convert the set back to a list and sort it\n    common_elements = sorted(list(common_elements))\n\n    return common_elements\n\n# Test cases"}
{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    Args:\n        n (int): A composite number greater than 1.\n\n    Returns:\n        int: The largest prime factor of n.\n\n    Examples:\n        >>> largest_prime_factor(13195)\n        29\n        >>> largest_prime_factor(2048)\n        2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\n# Test cases"}
{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    This function calculates the sum of numbers from 1 to n.\n\n    Args:\n        n (int): The upper limit of the sum.\n\n    Returns:\n        int: The sum of numbers from 1 to n.\n    \"\"\"\n    # Use the formula for the sum of an arithmetic series: n * (n + 1) / 2\n    return n * (n + 1) // 2\n\n# Test cases"}
{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Checks if every opening bracket in the string has a corresponding closing bracket.\n\n    Args:\n    brackets (str): A string consisting of \"(\" and \")\".\n\n    Returns:\n    bool: True if every opening bracket has a corresponding closing bracket, False otherwise.\n    \"\"\"\n    stack = []  # Initialize an empty stack\n\n    for bracket in brackets:\n        if bracket == \"(\":  # If the current character is an opening bracket\n            stack.append(bracket)  # Push it onto the stack\n        elif bracket == \")\":  # If the current character is a closing bracket\n            if not stack:  # If the stack is empty\n                return False  # Return False because there's no corresponding opening bracket\n            stack.pop()  # Pop the opening bracket from the stack\n\n    return not stack  # If the stack is empty after processing all brackets, return True; otherwise, return False\n\n# Test cases"}
{"task_id": "HumanEval/62", "solution": "def derivative(xs: list) -> list:\n    \"\"\"\n    This function calculates the derivative of a polynomial given its coefficients.\n\n    Args:\n    xs (list): A list of coefficients of a polynomial.\n               xs[0] + xs[1] * x + xs[2] * x^2 + ...\n\n    Returns:\n    list: A list of coefficients of the derivative of the polynomial.\n    \"\"\"\n    # Initialize an empty list to store the coefficients of the derivative\n    derivative_coeffs = []\n    \n    # Iterate over the coefficients of the polynomial, starting from the second coefficient\n    for i in range(1, len(xs)):\n        # The derivative of xs[i] * x^(i-1) is i * xs[i] * x^(i-2)\n        # So, we multiply each coefficient by its index and append it to the result\n        derivative_coeffs.append(i * xs[i])\n    \n    return derivative_coeffs\n\n# Test cases"}
{"task_id": "HumanEval/63", "solution": "def fibfib(n: int) -> int:\n    \"\"\"\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\n    Args:\n        n (int): The position of the number in the sequence.\n\n    Returns:\n        int: The nth number in the FibFib sequence.\n    \"\"\"\n    if n <= 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(2, n):\n            a, b, c = b, c, a + b + c\n        return c\n\n# Test cases"}
{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    \"\"\"\n    This function takes a string representing a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert the string to lowercase to simplify the vowel check\n    s = s.lower()\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Check each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in 'aeiou':\n            # If it's a vowel, increment the counter\n            count += 1\n        elif char == 'y' and s.endswith(char):\n            # If it's 'y' and it's at the end of the string, increment the counter\n            count += 1\n    \n    # Return the total count of vowels\n    return count\n\n# Test cases"}
{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    \"\"\"\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n\n    Args:\n        x (int): The input integer.\n        shift (int): The number of positions to shift the digits.\n\n    Returns:\n        str: The result of the circular shift as a string.\n    \"\"\"\n    # Convert the integer to a string to easily manipulate its digits\n    str_x = str(x)\n    \n    # Calculate the effective shift, considering the case where shift > number of digits\n    effective_shift = shift % len(str_x)\n    \n    # Split the string into two parts at the shift position\n    first_part = str_x[-effective_shift:]\n    second_part = str_x[:-effective_shift]\n    \n    # Combine the two parts in reverse order to get the result\n    result = first_part + second_part\n    \n    return result\n\n# Test cases"}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    \"\"\"\n    This function calculates the sum of ASCII values of upper case characters in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The sum of ASCII values of upper case characters in the string.\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n\n# Test cases"}
{"task_id": "HumanEval/67", "solution": "import re\n\ndef fruit_distribution(s, n):\n    \"\"\"\n    Calculate the number of mango fruits in a basket given the total number of fruits and a string describing the number of apples and oranges.\n\n    Args:\n        s (str): A string describing the number of apples and oranges in the basket.\n        n (int): The total number of fruits in the basket.\n\n    Returns:\n        int: The number of mango fruits in the basket.\n    \"\"\"\n    # Use regular expression to extract the number of apples and oranges from the string\n    match = re.search(r\"(\\d+) apples and (\\d+) oranges\", s)\n    if match:\n        apples, oranges = map(int, match.groups())\n    else:\n        raise ValueError(\"Invalid input string format\")\n\n    # Calculate the number of mango fruits\n    mangoes = n - apples - oranges\n\n    return mangoes\n\n# Test cases"}
{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smallest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Parameters:\n    arr (list): A list of non-negative integers representing a branch of a tree.\n\n    Returns:\n    list: A list containing the smallest even value and its index, or an empty list if no even values are found.\n    \"\"\"\n    # Filter the array to get only even values and their indices\n    even_values = [(value, index) for index, value in enumerate(arr) if value % 2 == 0]\n    \n    # If no even values are found, return an empty list\n    if not even_values:\n        return []\n    \n    # Find the smallest even value and its index\n    smallest_value, smallest_index = min(even_values, key=lambda x: (x[0], x[1]))\n    \n    return [smallest_value, smallest_index]\n\n# Test cases"}
{"task_id": "HumanEval/69", "solution": "def search(lst):\n    \"\"\"\n    Returns the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself.\n    If no such value exists, returns -1.\n\n    Args:\n        lst (list): A non-empty list of positive integers.\n\n    Returns:\n        int: The greatest integer that meets the condition, or -1 if no such value exists.\n    \"\"\"\n    # Create a dictionary to store the frequency of each integer in the list\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Initialize the result as -1\n    result = -1\n\n    # Iterate over the list in descending order\n    for num in sorted(lst, reverse=True):\n        # If the frequency of the current number is greater than or equal to the number itself\n        if freq_dict[num] >= num:\n            # Update the result\n            result = num\n            # Break the loop as we found the greatest number that meets the condition\n            break\n\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n\n    sorted_lst = sorted(lst)\n    result = []\n    i, j = 0, len(sorted_lst) - 1\n\n    while i <= j:\n        result.append(sorted_lst[i])\n        if i != j:\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/71", "solution": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    # Check if the three sides form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    \n    # Calculate the semi-perimeter\n    s = (a + b + c) / 2\n    \n    # Calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    # Return the area rounded to 2 decimal points\n    return round(area, 2)\n\n# Test the function"}
{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    \"\"\"\n    Returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Args:\n        q (list): A list of integers representing the object's elements.\n        w (int): The maximum possible weight.\n\n    Returns:\n        bool: True if the object will fly, False otherwise.\n    \"\"\"\n    # Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Check if the sum of the list's elements is less than or equal to the maximum possible weight\n    is_weight_valid = sum(q) <= w\n    \n    # Return True if both conditions are met, False otherwise\n    return is_palindrome and is_weight_valid\n\n# Test cases"}
{"task_id": "HumanEval/73", "solution": "from collections import Counter\n\ndef smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The minimum number of elements that need to be changed.\n    \"\"\"\n    # Count the frequency of each element in the array\n    freq = Counter(arr)\n    \n    # Initialize the count of elements that need to be changed\n    changes = 0\n    \n    # Iterate over the frequency of each element\n    for count in freq.values():\n        # If the count is odd, we need to change the middle element\n        if count % 2 != 0:\n            changes += 1\n    \n    # The minimum number of changes is the sum of the counts of elements that need to be changed\n    return changes\n\n# Test cases"}
{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Returns the list with the total number of characters less than the other list.\n    If the two lists have the same number of characters, returns the first list.\n\n    Args:\n        lst1 (list): The first list of strings.\n        lst2 (list): The second list of strings.\n\n    Returns:\n        list: The list with the total number of characters less than the other list.\n    \"\"\"\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total number of characters in each list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2\n\n# Test cases"}
{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(n):\n    \"\"\"\n    Returns True if the given number is the multiplication of 3 prime numbers, False otherwise.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: Whether the number is the multiplication of 3 prime numbers.\n    \"\"\"\n    \n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Find all prime factors of the number\n    factors = set()\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.add(i)\n            n //= i\n\n    # Check if there are exactly 3 prime factors\n    return len(factors) == 3 and all(is_prime(factor) for factor in factors)\n\n# Test the function"}
{"task_id": "HumanEval/76", "solution": "def is_simple_power(x, n):\n    \"\"\"\n    Returns True if a number x is a simple power of n, False otherwise.\n    \n    A number x is a simple power of n if n**int(x**(1/n)) == x.\n    \n    Parameters:\n    x (int): The number to check.\n    n (int): The base number.\n    \n    Returns:\n    bool: True if x is a simple power of n, False otherwise.\n    \"\"\"\n    if n <= 0 or x <= 0:\n        return False\n    root = round(x ** (1.0 / n))\n    return n ** root == x\n\n# Test cases"}
{"task_id": "HumanEval/77", "solution": "def iscube(a):\n    '''\n    Checks if a given integer is a cube of some integer number.\n\n    Args:\n        a (int): The input integer to be checked.\n\n    Returns:\n        bool: True if the integer is a cube, False otherwise.\n    '''\n    # Calculate the cube root of the input number\n    cube_root = round(a ** (1. / 3))\n    \n    # Check if the cube of the cube root equals the input number\n    return cube_root ** 3 == a\n\n# Test cases"}
{"task_id": "HumanEval/78", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef hex_key(num):\n    \"\"\"Count the number of hexadecimal digits that are prime.\"\"\"\n    prime_hex_digits = '23B7D'\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    return count\n\n# Test cases"}
{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    \"\"\"\n    Converts a decimal number to binary format with 'db' at the beginning and end.\n\n    Args:\n        decimal (int): The decimal number to convert.\n\n    Returns:\n        str: A string representing the binary number with 'db' at the beginning and end.\n    \"\"\"\n    # Convert decimal to binary and remove the '0b' prefix\n    binary = bin(decimal)[2:]\n    \n    # Add 'db' at the beginning and end of the binary string\n    binary = 'db' + binary + 'db'\n    \n    return binary\n\n# Test cases"}
{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    \"\"\"\n    Checks if a given string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n\n    Args:\n        s (str): The input string to check.\n\n    Returns:\n        bool: True if the string is happy, False otherwise.\n    \"\"\"\n    # Check if the string length is at least 3\n    if len(s) < 3:\n        return False\n\n    # Iterate over the string in steps of 3\n    for i in range(0, len(s), 3):\n        # Get the current 3 characters\n        chars = s[i:i+3]\n        \n        # Check if all characters are distinct\n        if len(chars) != len(set(chars)):\n            return False\n\n    # If we've checked all 3-character substrings and haven't returned False, the string is happy\n    return True\n\n# Test cases"}
{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    \"\"\"\n    This function takes a list of GPAs and returns a list of corresponding letter grades.\n\n    Args:\n        grades (list): A list of GPAs.\n\n    Returns:\n        list: A list of letter grades.\n    \"\"\"\n    # Define a dictionary to map GPAs to letter grades\n    grade_map = {\n        'A+': (4.0, float('inf')),\n        'A': (3.7, 4.0),\n        'A-': (3.3, 3.7),\n        'B+': (3.0, 3.3),\n        'B': (2.7, 3.0),\n        'B-': (2.3, 2.7),\n        'C+': (2.0, 2.3),\n        'C': (1.7, 2.0),\n        'C-': (1.3, 1.7),\n        'D+': (1.0, 1.3),\n        'D': (0.7, 1.0),\n        'D-': (0.0, 0.7),\n        'E': (0.0, 0.0)\n    }\n\n    # Initialize an empty list to store the letter grades\n    letter_grades = []\n\n    # Iterate over each GPA in the input list\n    for grade in grades:\n        # Initialize a flag to indicate if the grade has been matched\n        matched = False\n\n        # Iterate over each grade in the grade map\n        for letter, (lower, upper) in grade_map.items():\n            # Check if the GPA is within the range of the current grade\n            if lower < grade <= upper:\n                # If it is, append the letter grade to the list and set the flag to True\n                letter_grades.append(letter)\n                matched = True\n                break\n\n        # If the GPA is not matched, append 'E' to the list\n        if not matched:\n            letter_grades.append('E')\n\n    # Return the list of letter grades\n    return letter_grades\n\n# Test the function"}
{"task_id": "HumanEval/82", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef prime_length(string):\n    \"\"\"Check if the length of a string is a prime number.\"\"\"\n    return is_prime(len(string))\n\n# Test cases"}
{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n\n    Args:\n        n (int): The number of digits in the integers.\n\n    Returns:\n        int: The count of n-digit positive integers that start or end with 1.\n    \"\"\"\n    # Calculate the total number of n-digit positive integers\n    total_count = 9 * (10 ** (n - 1))\n    \n    # Calculate the count of n-digit positive integers that start with 1\n    start_with_one_count = 10 ** (n - 1)\n    \n    # Calculate the count of n-digit positive integers that end with 1\n    end_with_one_count = 9 * (10 ** (n - 2))\n    \n    # The count of n-digit positive integers that start or end with 1 is the sum of\n    # the count of n-digit positive integers that start with 1 and the count of\n    # n-digit positive integers that end with 1, minus the count of n-digit\n    # positive integers that start and end with 1\n    return start_with_one_count + end_with_one_count - 1\n\n# Test cases"}
{"task_id": "HumanEval/84", "solution": "def sum_of_binary_digits(N):\n    \"\"\"\n    Given a positive integer N, return the total sum of its digits in binary.\n    \n    Parameters:\n    N (int): A positive integer between 0 and 10000 (inclusive).\n    \n    Returns:\n    str: A string of binary number representing the sum of digits of N in binary.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(N)[2:]\n    \n    # Calculate the sum of the digits\n    digit_sum = sum(int(digit) for digit in binary)\n    \n    # Convert the sum back to binary and remove the '0b' prefix\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Test cases"}
{"task_id": "HumanEval/85", "solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)\n\n# Test the function"}
{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns an ordered version of the input string where all words are replaced by a new word\n    where all the characters are arranged in ascending order based on ASCII value.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The ordered version of the input string.\n    \"\"\"\n    # Split the string into words\n    words = s.split()\n\n    # Initialize an empty list to store the ordered words\n    ordered_words = []\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Remove any non-alphabetic characters from the word\n        cleaned_word = ''.join(filter(str.isalpha, word))\n\n        # Sort the characters in the cleaned word in ascending order based on ASCII value\n        ordered_word = ''.join(sorted(cleaned_word))\n\n        # Add the ordered word to the list of ordered words\n        ordered_words.append(ordered_word)\n\n    # Join the ordered words back into a string with spaces in between\n    ordered_string = ' '.join(ordered_words)\n\n    # Return the ordered string\n    return ordered_string\n\n# Test cases"}
{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in the list and return list of tuples, \n    [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate \n    - (row, columns), starting with 0. Sort coordinates initially by rows \n    in ascending order. Also, sort coordinates of the row by columns in descending order.\n\n    Args:\n        lst (list): A 2 dimensional data, as a nested lists.\n        x (int): The integer to find in the list.\n\n    Returns:\n        list: A list of tuples, each tuple is a coordinate - (row, columns).\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        if x in row:\n            result.extend([(i, j) for j, val in enumerate(row) if val == x])\n    return sorted(result, key=lambda x: (x[0], -x[1]))\n\n# Test cases"}
{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Args:\n        array (list): A list of non-negative integers.\n\n    Returns:\n        list: A copy of the given array sorted according to the problem's rules.\n    \"\"\"\n    # Create a copy of the array to avoid modifying the original array\n    array_copy = array.copy()\n\n    # Check if the array is not empty\n    if len(array_copy) > 0:\n        # Calculate the sum of the first and last elements\n        first_last_sum = array_copy[0] + array_copy[-1]\n\n        # Sort the array in ascending order if the sum is odd, or in descending order if the sum is even\n        array_copy.sort(reverse=(first_last_sum % 2 == 0))\n\n    return array_copy\n\n# Test cases"}
{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting the alphabet down by 4 places.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int or None: The 2nd smallest element of the list, or None if it does not exist.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_lst = set(lst)\n    \n    # If the list has less than 2 unique elements, return None\n    if len(unique_lst) < 2:\n        return None\n    \n    # Remove the smallest element\n    unique_lst.remove(min(unique_lst))\n    \n    # Return the smallest element from the remaining set\n    return min(unique_lst)\n\n# Test cases"}
{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n    \"\"\"\n    Counts the number of boredoms in a given string of words.\n    A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    Args:\n        S (str): The input string of words.\n\n    Returns:\n        int: The number of boredoms in the string.\n    \"\"\"\n    sentences = S.replace('?', '.').replace('!', '.').split('.')\n    boredoms = [sentence.strip() for sentence in sentences if sentence.strip() and sentence.strip()[0].lower() == 'i']\n    return len(boredoms)\n\n# Test cases"}
{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    '''\n    Returns true if one of the numbers is equal to the sum of the other two, \n    and all numbers are integers. Returns false in any other cases.\n    \n    Parameters:\n    x (int): The first number\n    y (int): The second number\n    z (int): The third number\n    \n    Returns:\n    bool: Whether the condition is met\n    '''\n    # Check if all numbers are integers\n    if not all(isinstance(i, int) for i in [x, y, z]):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    return (x == y + z or y == x + z or z == x + y)\n\n# Test cases"}
{"task_id": "HumanEval/93", "solution": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping case of all letters, replacing vowels with the letter 2 places ahead in the alphabet.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the vowels in lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n\n    # Initialize an empty string to store the encoded message\n    encoded_message = ''\n\n    # Iterate over each character in the message\n    for char in message:\n        # Check if the character is a vowel\n        if char in vowels:\n            # Find the index of the vowel in the vowels string\n            index = vowels.index(char)\n            # Calculate the new index by adding 2, wrapping around to the start of the string if necessary\n            new_index = (index + 2) % 6\n            # Append the character at the new index to the encoded message\n            encoded_message += vowels[new_index]\n        else:\n            # If the character is not a vowel, swap its case and append it to the encoded message\n            encoded_message += char.swapcase()\n\n    return encoded_message\n\n# Test the function"}
{"task_id": "HumanEval/94", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef largest_prime(lst):\n    \"\"\"Find the largest prime value in a list and return the sum of its digits.\"\"\"\n    max_prime = None\n    for num in lst:\n        if is_prime(num) and (max_prime is None or num > max_prime):\n            max_prime = num\n    if max_prime is None:\n        return 0  # Return 0 if no prime numbers are found\n    return sum(int(digit) for digit in str(max_prime))\n\n# Test cases"}
{"task_id": "HumanEval/95", "solution": "def check_dict_case(dictionary):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function returns False if the given dictionary is empty.\n    \n    Parameters:\n    dictionary (dict): The input dictionary to check.\n    \n    Returns:\n    bool: True if all keys are in lower or upper case, False otherwise.\n    \"\"\"\n    if not dictionary:  # Check if the dictionary is empty\n        return False\n    \n    all_lower = all(isinstance(key, str) and key.islower() for key in dictionary.keys())\n    all_upper = all(isinstance(key, str) and key.isupper() for key in dictionary.keys())\n    \n    return all_lower or all_upper\n\n# Test cases"}
{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    \"\"\"\n    Returns a list of the first n integers that are prime numbers and less than n.\n\n    Args:\n        n (int): A non-negative integer.\n\n    Returns:\n        list: A list of prime numbers less than n.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_numbers = []\n    for i in range(2, n):\n        if is_prime(i):\n            prime_numbers.append(i)\n        if len(prime_numbers) == n - 1:  # stop when we have n-1 prime numbers\n            break\n    return prime_numbers\n\n# Test cases"}
{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    \"\"\"\n    This function takes two integers and returns the product of their unit digits.\n    \n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    \n    Returns:\n    int: The product of the unit digits of a and b.\n    \"\"\"\n    # Extract the unit digit of each number using the modulus operator\n    unit_digit_a = a % 10\n    unit_digit_b = b % 10\n    \n    # Calculate the product of the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product\n\n# Test cases"}
{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    vowels = 'AEIOU'\n    count = 0\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.upper() in vowels:\n            count += 1\n    return count\n\n# Test cases"}
{"task_id": "HumanEval/99", "solution": "def closest_integer(value):\n    \"\"\"\n    Returns the closest integer to the given value, rounding away from zero if equidistant.\n\n    Args:\n        value (str): A string representing a number.\n\n    Returns:\n        int: The closest integer to the given value.\n    \"\"\"\n    # Convert the string to a float to perform calculations\n    num = float(value)\n    \n    # Use the built-in round function to round the number\n    # The second argument to round is the number of decimal places to round to\n    # We use -0 to round to the nearest integer\n    rounded_num = round(num, -0)\n    \n    # Return the rounded number as an integer\n    return int(rounded_num)\n\n# Test cases"}
{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Args:\n        n (int): A positive integer representing the number of levels in the pile.\n\n    Returns:\n        list: A list of integers representing the number of stones in each level.\n\n    Examples:\n        >>> make_a_pile(3)\n        [3, 5, 7]\n    \"\"\"\n    result = [n]\n    for _ in range(n - 1):\n        n += 1 if n % 2 else 2\n        result.append(n)\n    return result\n\n# Test the function"}
{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    \"\"\"\n    This function takes a string of words separated by commas or spaces and returns an array of the words.\n\n    Args:\n        s (str): The input string of words.\n\n    Returns:\n        list: A list of words from the input string.\n    \"\"\"\n    # Replace commas with spaces to make the string consistent\n    s = s.replace(\",\", \" \")\n    \n    # Split the string into words\n    words = s.split()\n    \n    # Return the list of words\n    return words\n\n# Test cases"}
{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"\n    This function takes two positive numbers x and y and returns the biggest even integer number \n    that is in the range [x, y] inclusive. If there's no such number, then the function \n    should return -1.\n\n    Args:\n        x (int): The lower bound of the range (inclusive).\n        y (int): The upper bound of the range (inclusive).\n\n    Returns:\n        int: The biggest even integer in the range [x, y] or -1 if no such number exists.\n    \"\"\"\n    # Check if both x and y are positive integers\n    if not isinstance(x, int) or not isinstance(y, int) or x <= 0 or y <= 0:\n        raise ValueError(\"Both x and y must be positive integers\")\n\n    # Find the biggest even number in the range [x, y]\n    even_num = y\n    while even_num > x and even_num % 2 != 0:\n        even_num -= 1\n\n    # Return the biggest even number if it exists, otherwise return -1\n    return even_num if even_num >= x else -1\n\n# Test cases"}
{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    \"\"\"\n    This function calculates the average of integers from n through m (inclusive), \n    rounds it to the nearest integer, and converts it to binary.\n\n    Args:\n        n (int): The start of the range (inclusive).\n        m (int): The end of the range (inclusive).\n\n    Returns:\n        str: The binary representation of the rounded average, or -1 if n > m.\n    \"\"\"\n    # Check if n is greater than m\n    if n > m:\n        return -1\n\n    # Calculate the sum of the range from n to m (inclusive)\n    total = sum(range(n, m + 1))\n\n    # Calculate the average\n    avg = total / (m - n + 1)\n\n    # Round the average to the nearest integer\n    rounded_avg = round(avg)\n\n    # Convert the rounded average to binary and remove the '0b' prefix\n    binary_avg = bin(rounded_avg)[2:]\n\n    return binary_avg\n\n# Test cases"}
{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    \"\"\"\n    Given a list of positive integers x. \n    Return a sorted list of all elements that hasn't any even digit.\n\n    Args:\n        x (list): A list of positive integers.\n\n    Returns:\n        list: A sorted list of integers without any even digits.\n    \"\"\"\n    def has_even_digit(n):\n        \"\"\"Check if a number has any even digit.\"\"\"\n        return any(int(digit) % 2 == 0 for digit in str(n))\n\n    return sorted([num for num in x if not has_even_digit(num)])\n\n# Test cases"}
{"task_id": "HumanEval/105", "solution": "def digit_name(n):\n    \"\"\"Return the name of a digit from 1 to 9.\"\"\"\n    names = [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    return names[n]\n\ndef by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        list: A list of string names of digits.\n    \"\"\"\n    # Filter the array to include only integers between 1 and 9\n    filtered_arr = [n for n in arr if 1 <= n <= 9]\n    \n    # Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Replace each digit with its corresponding name\n    result = [digit_name(n) for n in reversed_arr]\n    \n    return result\n\n# Test cases"}
{"task_id": "HumanEval/106", "solution": "import math\n\ndef f(n):\n    \"\"\"\n    Returns a list of size n, where the value at index i is the factorial of i if i is even,\n    or the sum of numbers from 1 to i otherwise.\n\n    Args:\n        n (int): The size of the list.\n\n    Returns:\n        list: A list of size n with the specified values.\n    \"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # If i is even, append the factorial of i to the result list\n            result.append(math.factorial(i))\n        else:\n            # If i is odd, append the sum of numbers from 1 to i to the result list\n            result.append(sum(range(1, i + 1)))\n    return result\n\n# Test the function"}
{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        tuple: A tuple containing the number of even and odd integer palindromes.\n\n    Example:\n        >>> even_odd_palindrome(3)\n        (1, 2)\n        >>> even_odd_palindrome(12)\n        (4, 6)\n    \"\"\"\n    def is_palindrome(num):\n        \"\"\"Check if a number is a palindrome.\"\"\"\n        return str(num) == str(num)[::-1]\n\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n\n# Test cases"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    \"\"\"\n    Counts the number of elements in the array which have a sum of digits > 0.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The number of elements with a sum of digits > 0.\n    \"\"\"\n    def sum_of_digits(n):\n        \"\"\"Helper function to calculate the sum of digits of a number.\"\"\"\n        return sum(int(digit) for digit in str(abs(n)))\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)\n\n# Test cases"}
{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    \"\"\"\n    Checks if it's possible to get an array sorted in non-decreasing order by performing right shift operations.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        bool: True if it's possible to get a sorted array, False otherwise.\n    \"\"\"\n    if not arr:  # If the array is empty, return True\n        return True\n\n    # Find the minimum element in the array\n    min_element = min(arr)\n\n    # Find the index of the minimum element\n    min_index = arr.index(min_element)\n\n    # If the minimum element is at the start of the array, it's possible to get a sorted array\n    if min_index == 0:\n        return True\n\n    # Check if the array can be sorted by right shifting\n    for i in range(min_index):\n        if arr[i] > arr[i + 1]:\n            return False\n\n    return True\n\n# Test cases"}
{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    \"\"\"\n    This function determines whether it is possible to perform an exchange of elements\n    between two lists to make the first list a list of only even numbers.\n\n    Args:\n        lst1 (list): The list to be converted to all even numbers.\n        lst2 (list): The list from which elements can be exchanged.\n\n    Returns:\n        str: \"YES\" if it is possible to make lst1 a list of only even numbers, \"NO\" otherwise.\n    \"\"\"\n    # Count the number of odd numbers in lst1\n    odd_count = sum(1 for num in lst1 if num % 2 != 0)\n    \n    # If the number of odd numbers in lst1 is greater than the number of odd numbers in lst2, return \"NO\"\n    if odd_count > sum(1 for num in lst2 if num % 2 != 0):\n        return \"NO\"\n    \n    # If the number of odd numbers in lst1 is less than or equal to the number of odd numbers in lst2, return \"YES\"\n    return \"YES\"\n\n# Test cases"}
{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    \"\"\"\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Args:\n        test (str): A string of space-separated lowercase letters.\n\n    Returns:\n        dict: A dictionary with letters as keys and their counts as values.\n    \"\"\"\n    # Split the input string into a list of letters\n    letters = test.split()\n\n    # Initialize an empty dictionary to store the counts of each letter\n    counts = {}\n\n    # Iterate over each letter in the list\n    for letter in letters:\n        # If the letter is already in the dictionary, increment its count\n        if letter in counts:\n            counts[letter] += 1\n        # If the letter is not in the dictionary, add it with a count of 1\n        else:\n            counts[letter] = 1\n\n    # Find the maximum count\n    max_count = max(counts.values(), default=0)\n\n    # Filter the dictionary to include only letters with the maximum count\n    max_counts = {letter: count for letter, count in counts.items() if count == max_count}\n\n    return max_counts\n\n# Test cases"}
{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    \"\"\"\n    This function deletes all characters in string s that are equal to any character in string c\n    and checks if the result string is a palindrome.\n\n    Args:\n        s (str): The original string.\n        c (str): The string containing characters to be deleted.\n\n    Returns:\n        tuple: A tuple containing the result string and a boolean indicating whether the result string is a palindrome.\n    \"\"\"\n    # Convert string c to a set for efficient lookups\n    c_set = set(c)\n    \n    # Use a list comprehension to filter out characters in s that are in c\n    result = [char for char in s if char not in c_set]\n    \n    # Join the list of characters back into a string\n    result_str = ''.join(result)\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result_str == result_str[::-1]\n    \n    return result_str, is_palindrome\n\n# Test cases"}
{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings, where each string consists of only digits.\n\n    Returns:\n        list: A list of strings, where each string is the number of odd elements in\n        the corresponding string of the input.\n    \"\"\"\n    return [f\"the number of odd elements {count}n the str{num}ng {num} of the {num}nput.\" \n            for num, count in enumerate([sum(int(digit) % 2 for digit in s) for s in lst])]\n\n# Test cases"}
{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The minimum sum of any non-empty sub-array of nums.\n    \"\"\"\n    if not nums:\n        return 0\n\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum\n\n# Test cases"}
{"task_id": "HumanEval/115", "solution": "import math\n\ndef max_fill(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Args:\n        grid (list): A 2D list representing the wells.\n        capacity (int): The capacity of the bucket.\n\n    Returns:\n        int: The number of times the bucket needs to be lowered.\n    \"\"\"\n    # Calculate the total number of wells\n    num_wells = len(grid)\n    \n    # Calculate the total number of water units\n    total_water = sum(sum(row) for row in grid)\n    \n    # Calculate the number of times the bucket needs to be lowered\n    # This is done by dividing the total number of water units by the bucket capacity\n    # and rounding up to the nearest integer\n    return math.ceil(total_water / capacity)\n\n# Test cases"}
{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    \"\"\"\n    Sorts an array of non-negative integers according to the number of ones in their binary representation in ascending order.\n    For similar number of ones, sorts based on decimal value.\n\n    Args:\n        arr (list): A list of non-negative integers.\n\n    Returns:\n        list: The sorted list of integers.\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n\n# Test cases"}
{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    \"\"\"\n    Returns a list of all words from string s that contain exactly n consonants.\n    \n    Parameters:\n    s (str): The input string.\n    n (int): The number of consonants in the words to be selected.\n    \n    Returns:\n    list: A list of words with exactly n consonants.\n    \"\"\"\n    # Define a helper function to check if a character is a vowel\n    def is_vowel(char):\n        return char.lower() in 'aeiou'\n    \n    # Split the string into words\n    words = s.split()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each word in the list of words\n    for word in words:\n        # Initialize a counter for consonants\n        consonant_count = 0\n        \n        # Iterate over each character in the word\n        for char in word:\n            # Check if the character is not a space and not a vowel\n            if char != ' ' and not is_vowel(char):\n                # Increment the consonant count\n                consonant_count += 1\n        \n        # Check if the consonant count is equal to n\n        if consonant_count == n:\n            # Add the word to the result list\n            result.append(word)\n    \n    # Return the result list\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    \"\"\"\n    This function finds the closest vowel that stands between two consonants from the right side of the word.\n    \n    Args:\n        word (str): The input word to search for the closest vowel.\n    \n    Returns:\n        str: The closest vowel that stands between two consonants from the right side of the word. \n             If no such vowel is found, an empty string is returned.\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    word = word[::-1]  # Reverse the word to start searching from the end\n    \n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i + 1] not in vowels:\n            if word[i + 1] in vowels:\n                return word[i + 1]\n    \n    return \"\"  # If no vowel is found, return an empty string\n\n# Test cases"}
{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    \"\"\"\n    Checks if it's possible to concatenate two strings of parentheses in some order\n    to get a balanced string.\n\n    Args:\n        lst (list): A list of two strings, each consisting of open '(' or close ')' parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    \"\"\"\n    def is_balanced(s):\n        \"\"\"Checks if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'\n\n# Test cases"}
{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): A positive integer.\n\n    Returns:\n        list: A sorted list of length k with the maximum k numbers in arr.\n\n    Example:\n        >>> maximum([-3, -4, 5], 3)\n        [-4, -3, 5]\n        >>> maximum([4, -4, 4], 2)\n        [4, 4]\n        >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n        [2]\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array\n    return sorted_arr[:k]\n\n# Test cases"}
{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of all odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)\n\n# Test cases"}
{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): The number of elements to consider from the start of the list.\n\n    Returns:\n        int: The sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n        >>> add_elements([111,21,3,4000,5,6,7,8,9], 4)\n        24\n    \"\"\"\n    return sum(num for num in arr[:k] if num <= 99)\n\n# Test the function"}
{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        list: A sorted list of odd numbers in the Collatz sequence.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        if n % 2 != 0:  # Check if n is odd before appending\n            collatz_sequence.append(n)\n\n    # Remove duplicates and sort the list\n    collatz_sequence = sorted(set(collatz_sequence))\n\n    return collatz_sequence\n\n# Example usage:"}
{"task_id": "HumanEval/124", "solution": "def valid_date(date):\n    \"\"\"\n    Validates a given date string.\n\n    Args:\n    date (str): The date string to be validated.\n\n    Returns:\n    bool: True if the date is valid, False otherwise.\n    \"\"\"\n    # Split the date string into month, day, and year\n    try:\n        month, day, year = date.split('-')\n    except ValueError:\n        return False  # Date string is not in the correct format\n\n    # Check if the date string is not empty\n    if not date:\n        return False\n\n    # Check if the month is valid\n    if not (1 <= int(month) <= 12):\n        return False\n\n    # Check if the day is valid\n    if int(month) in [1, 3, 5, 7, 8, 10, 12]:\n        if not (1 <= int(day) <= 31):\n            return False\n    elif int(month) in [4, 6, 9, 11]:\n        if not (1 <= int(day) <= 30):\n            return False\n    elif int(month) == 2:\n        if not (1 <= int(day) <= 29):\n            return False\n\n    # Check if the year is valid\n    if not (1900 <= int(year) <= 9999):\n        return False\n\n    return True\n\n# Test cases"}
{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words split on whitespace, \n    if no whitespaces exists in the text you should split on commas ',' \n    if no commas exists you should return the number of lower-case letters with odd order in the alphabet.\n\n    Args:\n        txt (str): The input string.\n\n    Returns:\n        list or int: A list of words or the count of lower-case letters with odd order in the alphabet.\n    \"\"\"\n    # Check if the string contains any whitespace\n    if ' ' in txt:\n        # Split the string on whitespace\n        return txt.split()\n    # Check if the string contains any commas\n    elif ',' in txt:\n        # Split the string on commas\n        return txt.split(',')\n    else:\n        # Count the number of lower-case letters with odd order in the alphabet\n        return sum(1 for i, c in enumerate(txt) if c.islower() and ord(c) % 2 == 1)\n\n# Test cases"}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: Whether the list is sorted and has no duplicate numbers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n    # Check if the list is sorted\n    if lst != sorted(lst):\n        return False\n\n    # Check for duplicate numbers\n    if len(lst) != len(set(lst)):\n        return False\n\n    return True\n\n# Test cases"}
{"task_id": "HumanEval/127", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    \"\"\"Check if the length of intersection of two intervals is a prime number.\"\"\"\n    # Find the intersection of the two intervals\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    # Check if the intervals intersect\n    if start > end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = end - start + 1\n    \n    # Check if the length of the intersection is a prime number\n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test cases"}
{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int or None: The sum of magnitudes of integers multiplied by product of all signs.\n                    Returns None for an empty list.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        return None\n\n    sign_product = 1  # Initialize the product of signs\n    for num in arr:\n        if num < 0:  # If the number is negative, multiply the sign product by -1\n            sign_product *= -1\n        elif num > 0:  # If the number is positive, keep the sign product as it is\n            continue\n        else:  # If the number is zero, the sign product remains the same\n            continue\n\n    return sum(abs(num) for num in arr) * sign_product  # Return the sum of magnitudes multiplied by the sign product\n\n# Test cases"}
{"task_id": "HumanEval/129", "solution": "from collections import deque\n\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Args:\n        grid (list): A 2D list representing the grid.\n        k (int): The length of the path.\n\n    Returns:\n        list: An ordered list of the values on the cells that the minimum path go through.\n    \"\"\"\n    def get_neighbors(i, j):\n        \"\"\"Get the neighbors of a cell at position (i, j)\"\"\"\n        neighbors = []\n        for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]):\n                neighbors.append((x, y))\n        return neighbors\n\n    def bfs(start):\n        \"\"\"Perform a breadth-first search from the start cell\"\"\"\n        queue = deque([(start, [grid[start[0]][start[1]])])\n        visited = set([start])\n        while queue:\n            (i, j), path = queue.popleft()\n            if len(path) == k:\n                return path\n            for x, y in get_neighbors(i, j):\n                if (x, y) not in visited:\n                    queue.append(((x, y), path + [grid[x][y]])\n                    visited.add((x, y))\n        return None\n\n    min_path = None\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            path = bfs((i, j))\n            if min_path is None or path < min_path:\n                min_path = path\n    return min_path\n\n# Test cases\ngrid = [[1,2,3], [4,5,6], [7,8,9]]\nk = 3"}
{"task_id": "HumanEval/130", "solution": "def tri(n):\n    \"\"\"\n    Returns the first n + 1 numbers of the Tribonacci sequence.\n\n    Args:\n        n (int): A non-negative integer.\n\n    Returns:\n        list: A list of the first n + 1 numbers of the Tribonacci sequence.\n    \"\"\"\n    if n == 0:\n        return []\n    elif n == 1:\n        return [3]\n    elif n == 2:\n        return [1, 3]\n    else:\n        sequence = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                sequence.append(1 + i / 2)\n            else:\n                sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i - 3])\n        return sequence\n\n# Test cases"}
{"task_id": "HumanEval/131", "solution": "def digits(n):\n    \"\"\"\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        int: The product of the odd digits of n, or 0 if all digits are even.\n    \"\"\"\n    product = 1\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n    return product\n\n# Test cases"}
{"task_id": "HumanEval/132", "solution": "def is_nested(string):\n    \"\"\"\n    Checks if a string of square brackets contains a valid subsequence with at least one nested bracket.\n\n    Args:\n        string (str): A string containing only square brackets.\n\n    Returns:\n        bool: True if the string contains a valid subsequence with at least one nested bracket, False otherwise.\n    \"\"\"\n    stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) > 0\n\n# Test cases"}
{"task_id": "HumanEval/133", "solution": "import math\n\ndef sum_squares(lst):\n    \"\"\"\n    This function calculates the sum of squares of numbers in a list.\n    Each number in the list is rounded up to the nearest integer before squaring.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of squares of numbers in the list.\n    \"\"\"\n    return sum(math.ceil(num) ** 2 for num in lst)\n\n# Test cases"}
{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    Returns True if the last character of a given string is an alphabetical character\n    and is not a part of a word, and False otherwise.\n\n    Args:\n        txt (str): The input string.\n\n    Returns:\n        bool: Whether the last character is an alphabetical character not part of a word.\n    \"\"\"\n    # Remove leading and trailing spaces\n    txt = txt.strip()\n    \n    # If the string is empty, return False\n    if not txt:\n        return False\n    \n    # Split the string into words\n    words = txt.split()\n    \n    # Get the last word\n    last_word = words[-1]\n    \n    # If the last word is a single character, return True if it's alphabetical\n    if len(last_word) == 1:\n        return last_word.isalpha()\n    \n    # If the last character of the last word is alphabetical, return True\n    return last_word[-1].isalpha()\n\n# Test cases"}
{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    \"\"\"\n    Returns the largest index of an element which is not greater than or equal to \n    the element immediately preceding it. If no such element exists then return -1.\n\n    Args:\n        arr (list): A list of unique integers.\n\n    Returns:\n        int: The largest index of an element which is not greater than or equal to \n             the element immediately preceding it, or -1 if no such element exists.\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] <= arr[i - 1]:\n            return i - 1\n    return -1\n\n# Test cases"}
{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    \"\"\"\n    Returns a tuple (a, b), where 'a' is the largest of negative integers,\n    and 'b' is the smallest of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        tuple: A tuple containing the largest negative integer and the smallest positive integer.\n    \"\"\"\n    negative_integers = [num for num in lst if num < 0]\n    positive_integers = [num for num in lst if num > 0]\n\n    if not negative_integers:\n        a = None\n    else:\n        a = max(negative_integers)\n\n    if not positive_integers:\n        b = None\n    else:\n        b = min(positive_integers)\n\n    return a, b\n\n# Test cases"}
{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    \"\"\"\n    Compare two real numbers and return the larger one in its given type.\n    \n    Args:\n        a (int, float, str): The first real number.\n        b (int, float, str): The second real number.\n    \n    Returns:\n        int, float, str: The larger real number in its given type, or None if the values are equal.\n    \"\"\"\n    \n    # Convert strings to floats to handle decimal points and commas\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n    \n    # Compare the numbers and return the larger one\n    if a > b:\n        return a\n    elif a < b:\n        return b\n    else:\n        return None\n\n# Test cases"}
{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    \"\"\"\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n can be written as the sum of exactly 4 positive even numbers, False otherwise.\n    \"\"\"\n    def can_be_written_as_sum_of_four_even_numbers(num):\n        # Generate all possible combinations of 4 even numbers\n        for i in range(2, num, 2):\n            for j in range(i, num, 2):\n                for k in range(j, num, 2):\n                    for last in range(k, num, 2):\n                        if i + j + k + last == num:\n                            return True\n        return False\n\n    return can_be_written_as_sum_of_four_even_numbers(n)\n\n# Test cases"}
{"task_id": "HumanEval/139", "solution": "def special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        int: The special factorial of n.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n\n    return result\n\nimport math\n\n# Test the function"}
{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with -\n\n    Args:\n        text (str): The input string to be processed.\n\n    Returns:\n        str: The processed string.\n    \"\"\"\n    # Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace all consecutive spaces with a single '-'\n    while '  ' in text:\n        text = text.replace('  ', '-')\n    \n    return text\n\n# Test cases"}
{"task_id": "HumanEval/141", "solution": "import re\n\ndef file_name_check(file_name):\n    \"\"\"\n    Check if a file name is valid.\n\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'.\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphabet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll'].\n\n    Args:\n        file_name (str): The name of the file to check.\n\n    Returns:\n        str: 'Yes' if the file's name is valid, 'No' otherwise.\n    \"\"\"\n    # Check if the file name contains exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n\n    # Split the file name into two parts: before and after the dot\n    before_dot, after_dot = file_name.split('.')\n\n    # Check if the substring before the dot is not empty and starts with a letter\n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n\n    # Check if the substring after the dot is one of the allowed extensions\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    # Check if there are more than three digits in the file name\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n\n    # If all checks pass, the file name is valid\n    return 'Yes'\n\n# Test cases"}
{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    \"\"\"\n    This function takes a list of integers, squares the integer entry if its index is a multiple of 3, \n    cubes the integer entry if its index is a multiple of 4 and not a multiple of 3, \n    and returns the sum of all entries.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of all entries after applying the specified operations.\n    \"\"\"\n    return sum(\n        num ** 2 if i % 3 == 0 else \n        num ** 3 if i % 4 == 0 and i % 3 != 0 else \n        num for i, num in enumerate(lst)\n    )\n\n# Test cases"}
{"task_id": "HumanEval/143", "solution": "def is_prime(n):\n    \"\"\"\n    Helper function to check if a number is prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef words_in_sentence(sentence):\n    \"\"\"\n    Returns a string containing the words from the original sentence,\n    whose lengths are prime numbers, in the same order.\n\n    Args:\n    sentence (str): The input sentence.\n\n    Returns:\n    str: The resulting string.\n    \"\"\"\n    words = sentence.split()\n    result = [word for word in words if is_prime(len(word))]\n    return ' '.join(result)\n\n\n# Test cases"}
{"task_id": "HumanEval/144", "solution": "from fractions import Fraction\n\ndef simplify(x, n):\n    \"\"\"\n    This function simplifies the expression x * n and returns True if the result is a whole number, False otherwise.\n\n    Args:\n        x (str): A string representation of a fraction in the format 'numerator/denominator'.\n        n (str): A string representation of a fraction in the format 'numerator/denominator'.\n\n    Returns:\n        bool: True if the product of x and n is a whole number, False otherwise.\n    \"\"\"\n    # Convert the input strings to Fraction objects\n    frac_x = Fraction(x)\n    frac_n = Fraction(n)\n\n    # Multiply the fractions\n    product = frac_x * frac_n\n\n    # Check if the product is a whole number (i.e., its denominator is 1)\n    return product.denominator == 1\n\n# Test cases"}
{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    \"\"\"\n    Sorts the given list of integers in ascending order according to the sum of their digits.\n    If there are several items with similar sum of their digits, order them based on their index in original list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: The sorted list of integers.\n    \"\"\"\n    # Use the sorted function with a custom key function that calculates the sum of digits and the original index\n    return sorted(enumerate(nums), key=lambda x: (sum(int(digit) for digit in str(abs(x[1])), x[0]))\n\n# Test cases"}
{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    \"\"\"\n    This function takes an array of numbers as input and returns the number of elements \n    in the array that are greater than 10 and both first and last digits of a number are odd.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The number of elements in the array that meet the specified conditions.\n    \"\"\"\n    count = 0\n    for num in nums:\n        # Check if the number is greater than 10\n        if num > 10:\n            # Convert the number to a string to easily access its first and last digits\n            str_num = str(abs(num))  # abs() is used to handle negative numbers\n            # Check if both first and last digits are odd\n            if int(str_num[0]) % 2 != 0 and int(str_num[-1]) % 2 != 0:\n                count += 1\n    return count\n\n# Test cases"}
{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    \"\"\"\n    Returns the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        int: The number of valid triples.\n    \"\"\"\n    def is_multiple_of_3(a, b, c):\n        \"\"\"Check if a + b + c is a multiple of 3.\"\"\"\n        return (a + b + c) % 3 == 0\n\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_multiple_of_3(a[i], a[j], a[k]):\n                    count += 1\n    return count\n\n# Test cases"}
{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    \"\"\"\n    Returns a tuple of planets whose orbits are between the orbits of planet1 and planet2.\n\n    Args:\n        planet1 (str): The name of the first planet.\n        planet2 (str): The name of the second planet.\n\n    Returns:\n        tuple: A tuple of planet names whose orbits are between the orbits of planet1 and planet2.\n    \"\"\"\n    # Define the order of planets in our solar system\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\n    # Check if both planet names are valid\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n\n    # Find the indices of planet1 and planet2 in the list of planets\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n\n    # If planet1 is after planet2, swap them\n    if idx1 > idx2:\n        idx1, idx2 = idx2, idx1\n\n    # Return the planets between planet1 and planet2\n    return tuple(planets[idx1 + 1:idx2])\n\n# Test cases"}
{"task_id": "HumanEval/149", "solution": "def list_sort(lst):\n    \"\"\"\n    Deletes the strings that have odd lengths from the list, \n    and returns the resulted list with a sorted order.\n    \n    The list is sorted by the length of each word in ascending order, \n    and if two words have the same length, it is sorted alphabetically.\n    \n    Args:\n        lst (list): A list of strings.\n    \n    Returns:\n        list: A list of strings in sorted order.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list\n\n# Test cases\nassert list_sort([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\nassert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]"}
{"task_id": "HumanEval/150", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    \"\"\"Return the value of x if n is a prime number, otherwise return y.\"\"\"\n    if is_prime(n):\n        return x\n    else:\n        return y\n\n# Test cases"}
{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Args:\n        lst (list): A list of numbers.\n    \n    Returns:\n        int: The sum of squares of the odd numbers in the list.\n    '''\n    # Filter out non-integer and negative numbers, and square the odd numbers\n    odd_squares = [num ** 2 for num in lst if isinstance(num, int) and num >= 0 and num % 2 != 0]\n    \n    # Return the sum of the squares\n    return sum(odd_squares)\n\n# Test cases"}
{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    \"\"\"\n    This function compares the given game scores with the guesses and returns an array\n    of the same length denoting how far off each guess was.\n\n    Args:\n        game (list): A list of actual game scores.\n        guess (list): A list of guessed scores.\n\n    Returns:\n        list: A list of absolute differences between the guesses and the actual scores.\n    \"\"\"\n    return [abs(g - s) if g != s else 0 for g, s in zip(game, guess)]\n\n# Test cases"}
{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    \"\"\"\n    This function finds the strongest extension for a given class.\n    \n    The strength of an extension is calculated as the difference between the number of uppercase letters and lowercase letters in its name.\n    \n    If there are multiple extensions with the same strength, the function returns the one that comes first in the list.\n    \n    Parameters:\n    class_name (str): The name of the class.\n    extensions (list): A list of extensions.\n    \n    Returns:\n    str: The name of the class followed by the strongest extension.\n    \"\"\"\n    \n    # Initialize the strongest extension and its strength\n    strongest_extension = ''\n    max_strength = float('-inf')  # Initialize max_strength as negative infinity\n    \n    # Iterate over each extension\n    for extension in extensions:\n        # Calculate the strength of the current extension\n        strength = sum(1 for char in extension if char.isupper()) - sum(1 for char in extension if char.islower())\n        \n        # If the strength of the current extension is greater than max_strength, update max_strength and strongest_extension\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    \n    # Return the class name followed by the strongest extension\n    return f\"{class_name}.{strongest_extension}\"\n\n# Test cases"}
{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    \"\"\"\n    Checks if the second word or any of its rotations is a substring in the first word.\n\n    Args:\n        a (str): The main word.\n        b (str): The word to check for rotations.\n\n    Returns:\n        bool: True if the second word or any of its rotations is a substring in the first word, False otherwise.\n    \"\"\"\n    # Generate all rotations of the second word\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation is a substring of the first word\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    # If no rotation is found, return False\n    return False\n\n# Test cases"}
{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        tuple: A tuple containing the count of even and odd digits.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n\n    # Convert the number to a string to easily iterate over each digit\n    for digit in str(abs(num)):\n        # Convert the digit back to an integer to check if it's even or odd\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return even_count, odd_count\n\n# Test cases"}
{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    if not isinstance(number, int) or not 1 <= number <= 1000:\n        raise ValueError(\"Input must be an integer between 1 and 1000\")\n\n    roman_numerals = {\n        1000: 'm',\n        900: 'cm',\n        500: 'd',\n        400: 'cd',\n        100: 'c',\n        90: 'xc',\n        50: 'l',\n        40: 'xl',\n        10: 'x',\n        9: 'ix',\n        5: 'v',\n        4: 'iv',\n        1: 'i'\n    }\n\n    result = ''\n    for value, numeral in roman_numerals.items():\n        while number >= value:\n            result += numeral\n            number -= value\n\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/157", "solution": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    \n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    \n    Parameters:\n    a (int): The length of the first side of the triangle.\n    b (int): The length of the second side of the triangle.\n    c (int): The length of the third side of the triangle.\n    \n    Returns:\n    bool: True if the three sides form a right-angled triangle, False otherwise.\n    '''\n    # Check if the sides can form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Check if the square of the longest side is equal to the sum of squares of the other two sides\n    sides = sorted([a, b, c])\n    return sides[0]**2 + sides[1]**2 == sides[2]**2\n\n# Test cases"}
{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    \"\"\"\n    This function finds the word with the maximum number of unique characters.\n    If multiple words have the same maximum number of unique characters, \n    it returns the one that comes first in lexicographical order.\n\n    Args:\n        words (list): A list of strings.\n\n    Returns:\n        str: The word with the maximum number of unique characters.\n    \"\"\"\n    # Initialize the maximum word and its unique characters count\n    max_word = \"\"\n    max_unique_chars = 0\n\n    # Iterate over each word in the list\n    for word in words:\n        # Count the unique characters in the current word\n        unique_chars = len(set(word))\n        \n        # If the current word has more unique characters than the max, update max_word and max_unique_chars\n        if unique_chars > max_unique_chars:\n            max_word = word\n            max_unique_chars = unique_chars\n        # If the current word has the same number of unique characters as the max, \n        # update max_word if it comes first in lexicographical order\n        elif unique_chars == max_unique_chars and word < max_word:\n            max_word = word\n\n    return max_word\n\n# Test cases"}
{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n\n    Args:\n        number (int): the number of carrots that you have eaten.\n        need (int): the number of carrots that you need to eat.\n        remaining (int): the number of remaining carrots that exist in stock\n\n    Returns:\n        list: a list containing the total number of eaten carrots and the number of carrots left after meals\n\n    Example:\n        * eat(5, 6, 10) -> [11, 4]\n        * eat(4, 8, 9) -> [12, 1]\n        * eat(1, 10, 10) -> [11, 0]\n        * eat(2, 11, 5) -> [7, 0]\n    \"\"\"\n    # Calculate the total number of carrots eaten\n    total_eaten = number + need\n    \n    # Calculate the number of carrots left after meals\n    carrots_left = remaining - need\n    \n    # If there are not enough remaining carrots, eat all remaining carrots\n    if carrots_left < 0:\n        total_eaten += remaining\n        carrots_left = 0\n    \n    return [total_eaten, carrots_left]\n\n# Test cases"}
{"task_id": "HumanEval/160", "solution": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    Args:\n        operator (list): A list of basic algebra operations.\n        operand (list): A list of integers.\n\n    Returns:\n        int: The evaluation of the algebraic expression.\n\n    Raises:\n        ValueError: If the length of operator list is not equal to the length of operand list minus one.\n        ValueError: If the operand list has less than two operands.\n    \"\"\"\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The length of operator list must be equal to the length of operand list minus one.\")\n    if len(operand) < 2:\n        raise ValueError(\"Operand list must have at least two operands.\")\n\n    # Initialize the result with the first operand\n    result = operand[0]\n    \n    # Iterate over the operators and operands\n    for i in range(len(operator)):\n        # Get the current operator and operand\n        op = operator[i]\n        operand_val = operand[i + 1]\n        \n        # Apply the operation based on the operator\n        if op == '+':\n            result += operand_val\n        elif op == '-':\n            result -= operand_val\n        elif op == '*':\n            result *= operand_val\n        elif op == '//':\n            result //= operand_val\n        elif op == '**':\n            result **= operand_val\n        else:\n            raise ValueError(\"Invalid operator\")\n\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/161", "solution": "def solve(s):\n    \"\"\"\n    This function takes a string s as input, \n    reverses the case of letters, and reverses the string if it contains no letters.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The modified string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Check if the character is uppercase or lowercase\n            if char.isupper():\n                result += char.lower()\n            else:\n                result += char.upper()\n        else:\n            # If the character is not a letter, add it as it is\n            result += char\n    # If the string contains no letters, reverse the string\n    if not any(char.isalpha() for char in s):\n        return result[::-1]\n    return result\n\n# Test cases"}
{"task_id": "HumanEval/162", "solution": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    Args:\n        text (str): The input string to be hashed.\n\n    Returns:\n        str: The md5 hash equivalent string of 'text' or None if 'text' is empty.\n    \"\"\"\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()\n\n# Test the function"}
{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    Args:\n        a (int): The lower bound (inclusive).\n        b (int): The upper bound (inclusive).\n\n    Returns:\n        list: A list of even digits between a and b, in ascending order.\n    \"\"\"\n    # Ensure a is less than or equal to b\n    if a > b:\n        a, b = b, a\n\n    # Generate a list of even numbers between a and b\n    even_numbers = [i for i in range(a, b + 1) if i % 2 == 0]\n\n    return even_numbers\n\n# Test cases"}
